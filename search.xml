<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构中有关二叉树问题的总结]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E6%9C%89%E5%85%B3%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[这是对于二叉树结构的一些基本总结，使用Java语言描述 二叉树有独特的性质，不包括特殊二叉树，需要熟悉 一般来说二叉树的题用递归方法做最为直观 一些题也可以借助队列来做 二叉树的结构1234567class TreeNode()&#123; int val; //左子树 TreeNode left; //右子树 TreeNode right;&#125; 求二叉树的最大深度 二叉树的最大深度就是根节点到最远子节点的距离 对于任意一个节点，它的深度就是它左右两个子节点的深度+112345678class Solution &#123;//解法：该方法使用递归的方法 public int maxDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; return Math.max(maxDepth(root.left), maxDepth(root.right))+1; &#125;&#125; 求二叉树中节点的个数12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; public: int countNodes(TreeNode* root) &#123; if(root == NULL) return 0; return countNodes(root.left) + countNodes(root.right) + 1; &#125; &#125;; 求二叉树中叶子节点的个数 没有子节点的节点称为叶子节点 本题依旧可以用递归调用的方法来做1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; public: int numOfLeafNode(TreeNode root)&#123; if(root == null) return 0; else if(root.left == null &amp;&amp; root.right == null) return 1; else if(root.left != null || root.right != null)//其实这一步不需要判断条件 return numOfLeafNode(root.left) + numOfLeafNode(root.right); &#125; &#125;; 求二叉树中第K层节点的个数 利用递归方法 若根节点为空，或者层数K &lt;= 0 ，则为空树或者不符合要求，返回0 若根节点不为空且此时层数K = 0 ，则此时的根节点就是K层节点，返回1 若根节点不为空且此时层数K &gt; 0 , 则返回此时根节点的左子树（K-1）层节点数与右子树（K-1）层节点数之和代码如下：12345678910int getBTreeKthLeverNOdesTotal(TreeNode root,int k)&#123; if(root == null || k &lt;= 0)&#123; return 0; &#125; else if(root != null &amp;&amp; k == 0)&#123; return 1; &#125; return getBTreeKthLeverNOdesTotal(root.left, k-1) + getBTreeKthLeverNOdesTotal(root.right, k-1);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
